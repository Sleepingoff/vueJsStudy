## 6. Computed Properties
* 링크: https://vuejs.org/guide/essentials/computed.html

### 문제 1: Vue.js에서 복잡한 로직을 템플릿에서 직접 처리하는 대신 사용하는 Vue의 기능은 무엇인가요?

### 문제 2: 다음 중 Vue.js에서 템플릿 내 복잡한 로직을 처리하는 권장 방법은 무엇인가요?

```
a) 직접적인 템플릿 표현식 사용
b) 계산된 속성 사용
c) 데이터 메서드 사용
d) 바로 reactive 객체 사용
```

### 문제 3: Vue에서 계산된 속성(computed property)의 주요 이점은 무엇인가요?

```
a) 항상 최신 상태를 유지한다.
b) 의존하는 반응형 데이터가 변경될 때만 다시 계산된다.
c) 템플릿에서 직접 수정할 수 있다.
d) 복잡한 데이터 변환을 필요로 하지 않는다.
```

### 문제 4: computed() 함수 내에서 사용되는 반환 값의 유형은 무엇인가요?

```
a) 문자열
b) 객체
c) 계산된 참조(computed ref)
d) 반응형 객체(reactive object)
```

### 문제 5: Vue에서 계산된 속성(computed properties)과 메서드(functions) 사이의 주요 차이점은 무엇인가요?

### 문제 6: Vue.js에서 계산된 속성과 메서드의 차이점에 관해 올바른 설명은 무엇인가요?

```
a) 메서드는 반응형 데이터에 기반한 캐싱을 제공하지만 계산된 속성은 제공하지 않는다.
b) 계산된 속성은 반응형 데이터에 의존할 때만 다시 계산되며 캐시된다, 반면 메서드는 재호출될 때마다 다시 실행된다.
c) 계산된 속성은 템플릿 내에서만 사용할 수 있고 메서드는 JavaScript 코드에서만 사용할 수 있다.
d) 메서드와 계산된 속성 모두 반응형 데이터의 변경에 따라 자동으로 업데이트되지 않는다.
```

### 문제 7: 다음 중 계산된 속성의 캐싱 기능이 필요 없는 경우에 적합한 선택은 무엇인가요?

```
a) 빈번하게 변경되는 데이터에 대한 계산
b) 큰 배열을 처리하는 비용이 많이 드는 계산
c) 의존하는 데이터가 자주 변경되지 않는 복잡한 계산
d) 재렌더링 될 때마다 항상 최신 상태를 반영해야 하는 계산
```

### 문제 8:
Vue.js 애플리케이션에서 다음과 같이 Date.now()를 사용하여 계산된 속성을 정의했습니다.

```js
const currentTime = computed(() => Date.now());
```
이 계산된 속성 currentTime이 애플리케이션 실행 도중에 업데이트되지 않는 이유는 무엇일까요?

```
a) Date.now()는 호출될 때마다 다른 값을 반환하기 때문이다.
b) Vue는 Date.now() 호출을 반응형 의존성으로 간주하지 않는다.
c) Date.now()는 반응형 데이터가 아니기 때문이다.
d) Vue는 시간 관련 데이터를 자동으로 업데이트할 수 없다.
```

### 문제 9: Vue에서 "쓰기 가능한" 계산된 속성을 생성하기 위해, 계산된 속성에 어떤 함수들을 제공해야 하나요?

### 문제 10: Vue.js에서 쓰기 가능한 계산된 속성을 정의할 때 필요한 것은 무엇입니까?

```
a) 오직 getter 함수만
b) 오직 setter 함수만
c) getter 함수와 setter 함수 둘 다
d) 계산된 속성은 쓰기 불가능하므로, 별도의 함수가 필요 없음
```

### 문제 11: 계산된 속성의 getter 함수 내에서 피해야 할 프로그래밍 실천은 무엇인가요?

### 문제 12: Vue.js에서 계산된 속성에 대한 모범 사례를 설명하는 것 중 올바른 것은 무엇입니까?

```
a) 계산된 속성은 그들의 의존성이 변할 때만 업데이트 되어야 한다.
b) 계산된 속성의 getter는 부수 효과를 발생시켜도 괜찮다.
c) 계산된 속성의 반환 값은 필요에 따라 직접 변경할 수 있다.
d) 계산된 속성의 getter 함수 내에서 DOM을 직접 조작하는 것이 권장된다.
```

### 설명:
* Vue.js에서 계산된 속성의 getter 함수는 순수한 계산을 수행해야 하며 부수 효과가 없어야 합니다.
* 계산된 속성의 반환 값은 파생된 상태로 간주되어 읽기 전용이어야 하며, 직접 변경해서는 안 됩니다.
* 필요한 경우, 의존하는 원본 상태를 업데이트하여 새로운 계산을 유발해야 합니다.
* 계산된 속성의 getter 내에서 DOM 조작과 같은 부수 효과를 발생시키는 것은 권장되지 않습니다.


<details>
  <summary>정답 보기</summary>

### 문제 1 답
* 계산된 속성(computed properties).
### 문제 2 답
* b) 계산된 속성 사용
### 문제 3 답
* b) 의존하는 반응형 데이터가 변경될 때만 다시 계산된다.
### 문제 4 답
* c) 계산된 참조(computed ref)
### 문제 5 답
* 계산된 속성은 의존하는 반응형 데이터가 변경될 때만 다시 계산되며 캐시되는 반면, 메서드는 호출될 때마다 함수를 실행합니다.
### 문제 6 답
* b) 계산된 속성은 반응형 데이터에 의존할 때만 다시 계산되며 캐시된다, 반면 메서드는 재호출될 때마다 다시 실행된다.
### 문제 7 답
* d) 재렌더링 될 때마다 항상 최신 상태를 반영해야 하는 계산
### 문제 8 답: 
* b) Vue는 Date.now() 호출을 반응형 의존성으로 간주하지 않는다.
### 설명: 
* Vue의 반응형 시스템은 반응형 데이터의 변경을 감지할 때만 계산된 속성을 다시 계산하고 업데이트합니다. 
* Date.now() 같은 함수는 Vue의 반응형 시스템에 의해 추적되지 않는 외부 소스에서 값을 가져옵니다
* Date.now()의 호출 결과는 반응형 의존성으로 간주되지 않습니다. 
* Date.now()를 사용하는 계산된 속성은 정의된 이후에 데이터 변화에 반응하여 자동으로 업데이트되지 않습니다.
### 문제 9 답
* getter 함수와 setter 함수
### 문제 10 답
* c) getter 함수와 setter 함수 둘 다
### 문제 11 답
* 부수 효과(side effects)를 발생시키는 작업을 피해야 합니다. 
  * 예를 들어, 다른 상태를 변경하거나 비동기 요청을 만들거나 DOM을 수정하는 것 등이 포함됩니다.
### 문제 12 답
* a) 계산된 속성은 그들의 의존성이 변할 때만 업데이트 되어야 한다.

</details>